name: Bump updatedAt & Rebuild registry

on:
  push:
    branches:
      - main
    paths:
      - "translations/**.json"
      - "!translations/registry.json"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update-translations:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find changed translation files
        id: diff
        run: |
          # Prefer the push event's "before" SHA to avoid origin/main == HEAD
          BASE=${GITHUB_EVENT_BEFORE:-${{ github.event.before }}}
          if [ -z "$BASE" ] || ! git cat-file -e "$BASE" 2>/dev/null; then
            BASE=$(git rev-parse HEAD^)
          fi
          FILES=$(git diff --name-only "$BASE"...HEAD -- translations/**.json ':!translations/registry.json' 2>/dev/null || true)
          # Fallback for edge cases
          if [ -z "$FILES" ]; then
            FILES=$(git diff --name-only HEAD^1 HEAD -- translations/**.json ':!translations/registry.json' 2>/dev/null || true)
          fi
          echo "Changed files (base=$BASE):"
          echo "$FILES"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Bump updatedAt in changed entries
        if: steps.diff.outputs.files != ''
        env:
          FILES: ${{ steps.diff.outputs.files }}
        run: |
          node <<'NODE'
          const fs = require('fs'), cp = require('child_process');
          const files = (process.env.FILES || '').split('\n').filter(Boolean);
          if (!files.length) process.exit(0);
          const now = Date.now();
          for (const file of files) {
            let prevJson;
            try {
              const prev = cp.execSync(`git show HEAD^:${file}`).toString('utf8');
              prevJson = JSON.parse(prev);
            } catch {
              prevJson = { entries: [] }; // new file or missing previous version
            }
            const curJson = JSON.parse(fs.readFileSync(file, 'utf8'));
            const oldMap = new Map((prevJson.entries || []).map(e => [e.key, e]));
            let changed = false;
            curJson.entries = (curJson.entries || []).map(e => {
              const prev = oldMap.get(e.key);
              const isNew = !prev;
              const sourceChanged = prev && prev.source !== e.source;
              const translatedChanged = prev && prev.translated !== e.translated;
              if (isNew || sourceChanged || translatedChanged) {
                changed = true;
                return { ...e, updatedAt: now };
              }
              return e;
            });
            if (changed) {
              fs.writeFileSync(file, JSON.stringify(curJson, null, 2));
              console.log(`bumped updatedAt in ${file}`);
            }
          }
          NODE

      - name: Rebuild registry.json
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const repo = process.env.GITHUB_REPOSITORY;
          const branch = process.env.GITHUB_REF_NAME || 'main';
          const root = path.join(process.cwd(), 'translations');
          const registryPath = path.join(root, 'registry.json');

          function walk(dir) {
            return fs.readdirSync(dir, { withFileTypes: true }).flatMap((ent) => {
              const p = path.join(dir, ent.name);
              if (ent.isDirectory()) return walk(p);
              return [p];
            });
          }

          function guessScope(file, lang, rawScope) {
            if (rawScope) return rawScope;
            const base = path.basename(file, '.json');
            const suffix = `_${lang}`;
            if (base.toLowerCase().endsWith(suffix.toLowerCase())) {
              return base.slice(0, -suffix.length);
            }
            return base;
          }

          const languages = {};

          for (const file of walk(root)) {
            if (file === registryPath) continue;
            if (!file.endsWith('.json')) continue;
            const rel = path.relative(root, file).split(path.sep);
            if (rel.length < 2) continue; // expect translations/<lang>/<file>
            const lang = rel[0];
            const raw = JSON.parse(fs.readFileSync(file, 'utf8'));
            const stats = fs.statSync(file);
            const scope = guessScope(file, lang, raw.scope);
            const entryCount = Array.isArray(raw.entries) ? raw.entries.length : 0;
            const downloadUrl = `https://raw.githubusercontent.com/${repo}/refs/heads/${branch}/${encodeURI(path.relative(process.cwd(), file).replace(/\\/g, '/'))}`;
            const item = {
              scope,
              name: raw.name || scope,
              description: raw.description,
              downloadUrl,
              updatedAt: Math.floor(stats.mtimeMs),
              entryCount,
              version: raw.version || 1,
              lang
            };
            languages[lang] ??= [];
            languages[lang].push(item);
          }

          for (const lang of Object.keys(languages)) {
            languages[lang].sort((a, b) => a.scope.localeCompare(b.scope));
          }

          const out = { languages };
          fs.writeFileSync(registryPath, JSON.stringify(out, null, 2));
          console.log('registry.json updated');
          NODE

      - name: Commit changes
        run: |
          if git diff --quiet translations; then
            echo "No changes to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add translations/**/*.json translations/registry.json
          git commit -m "chore: bump updatedAt & rebuild registry"
          git push
